ğŸ§± Buffer.alloc() vs Buffer.allocUnsafe()
ğŸ”¹ Buffer.alloc(size)
âœ… Creates a new buffer of the specified size
âœ… Initializes all bytes to 0
ğŸ›¡ï¸ Safe to use â€” prevents data leaks
ğŸ” Slower, since it wipes old memory (zero-fills)
const safeBuf = Buffer.alloc(10);
console.log(safeBuf); 
// <Buffer 00 00 00 00 00 00 00 00 00 00>
ğŸ§  When to use:
Use alloc() by default, especially when handling user data, passwords, or sensitive info.

ğŸ”¸ Buffer.allocUnsafe(size)
ğŸš€ Creates a new buffer but does NOT initialize memory
âš ï¸ Might contain random/leftover data from previous memory usage
âš¡ Faster because it skips zero-filling
ğŸ§¨ Unsafe unless you manually overwrite the contents
const unsafeBuf = Buffer.allocUnsafe(10);
console.log(unsafeBuf); 
// <Buffer 12 ff 00 78 9a ...> â† Unpredictable content!
ğŸ‘€ Why is it unsafe?
Node.js reuses memory for performance.
If you donâ€™t overwrite the buffer before use, you may accidentally leak private data.

âœ… When to Use What?
Method
Use Case
Buffer.alloc()
âœ”ï¸ Safe default, especially for sensitive/user-facing data
Buffer.allocUnsafe()
âš¡ Use only when performance matters AND you'll fill it manually


ğŸ§¼ Tip: How to zero-fill an allocUnsafe buffer
const buf = Buffer.allocUnsafe(10);
buf.fill(0); // âœ… Safely zero out the memory

ğŸ§ª Quick Demo
const a = Buffer.alloc(5);
const b = Buffer.allocUnsafe(5);
console.log(a); // <Buffer 00 00 00 00 00>
console.log(b); // <Buffer ?? ?? ?? ?? ??> â† Random data
ğŸ§  Best Practice: Always prefer alloc() unless you're doing performance-critical tasks and you're 100% sure the buffer will be overwritten.

ğŸ’¥ What does "leak private data" mean in this context?
When you use:
const buf = Buffer.allocUnsafe(10);
Node.js allocates 10 bytes of memory without clearing its previous contents.
This memory might have been used before by other parts of your app â€” and could contain sensitive data like:
ğŸ›¡ï¸ Passwords
ğŸ” API keys or tokens
ğŸ“§ Email addresses
ğŸ—‚ï¸ Database queries
ğŸ§  Anything previously stored in memory!
If you log or send this buffer (e.g., as an HTTP response or to a file), you might unintentionally expose this old data.

ğŸ§ª Example: Accidental Data Leak
Letâ€™s say earlier in your program you had:
const password = Buffer.from("MySecret123");
That gets garbage collected later...
Now you do:
const unsafeBuffer = Buffer.allocUnsafe(10);
console.log(unsafeBuffer.toString());
You might get something like:
MySecret1
ğŸ˜± Surprise! Your old password is still in memory â€” and now leaked through unsafeBuffer.

âœ… How to stay safe
If you must use Buffer.allocUnsafe() for performance, always overwrite the memory first:
const buf = Buffer.allocUnsafe(10);
buf.fill(0); // âœ… Clears old junk data