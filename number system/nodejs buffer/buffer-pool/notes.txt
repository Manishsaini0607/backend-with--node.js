ğŸ§µ Buffer Pool in Node.js ğŸ”
When we create buffers using Buffer.allocUnsafe(), Node.js uses a shared memory pool (an ArrayBuffer) to speed things up ğŸš€.

âš™ï¸ How It Works:
Node.js maintains a buffer pool of size 8 KiB = 8192 bytes.
Buffer.poolSize; // 8192
This pool is a single large ArrayBuffer shared across small Buffer instances.

âœ… Condition for Using Buffer Pool:
To be eligible to use the shared buffer pool:
BufferSize < Buffer.poolSize >>> 1
i.e.
ğŸ”¸ Buffer size < 4096 bytes (half of pool)
If:
âœ”ï¸ Size is small AND
âœ”ï¸ Enough space is available in the pool
â†’ âœ… The buffer will be allocated from the pool (faster, shared)
If:
âŒ Size â‰¥ 4096
OR
âŒ Not enough room left in pool
â†’ ğŸ†• A new ArrayBuffer is allocated exclusively for that buffer.

ğŸ¯ Practical Demo:
import { Buffer, constants } from "buffer";
const a = Buffer.alloc(4);           // Normal buffer
const b = Buffer.allocUnsafe(4);     // Fast! May use pool
const c = Buffer.allocUnsafeSlow(4); // Doesnâ€™t use pool at all

console.log(Buffer.poolSize); // 8192

console.log(constants.MAX_LENGTH); // Max buffer size (~2GB)
// Check underlying ArrayBuffer sizes:
console.log(a.buffer.byteLength); // 4 (same as byteLength)

console.log(b.buffer.byteLength); // 8192 (from pool!)

âš¡ Why allocUnsafe() is Fast?
It doesnâ€™t zero-fill memory, so saves time.
If pool is used, memory is already pre-allocated â€” just slice and return.
Shared memory usage avoids frequent allocation/deallocation.

â— Buffer.allocUnsafeSlow()
Creates a new buffer without using the pool.
Slower and more memory-consuming.
const slowBuffer = Buffer.allocUnsafeSlow(4);
console.log(slowBuffer.buffer.byteLength); // 4

ğŸ§  Bonus:
Buffer.from(), Buffer.concat() also use allocUnsafe() internally to boost performance.
You can modify pool size by:
Buffer.poolSize = 16384; // New size for future pools
But the first pool will still be 8192 â€” only future ones will use new size.

ğŸ“¦ Constants from Buffer:
import { Buffer, constants } from "buffer";
constants.MAX_LENGTH         // ~2 GB (Max Buffer size)
constants.MAX_STRING_LENGTH  // ~1 GB (Max String allowed)